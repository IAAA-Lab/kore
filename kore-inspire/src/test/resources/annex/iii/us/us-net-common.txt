Container <<applicationSchema>>  "Common Utility Network Elements" {
  Attributes "US_NET_COMMON_UtilityNetwork" {
    description = "Collection of network elements that belong to a single type of utility network.
  
    In the real world, objects are connected to each other: an optical cable is connected to a multiplexer that in turn is connected to copper cables connecting into our homes to provide cable TV, telephony and internet access. Using GIS to support network utility management typically involves many types of features that may have connectivity to each other. Topology in GIS is generally defined as the spatial relationship between connecting or adjacent features, and is an essential prerequisite for many spatial operations such as network analysis. Utility networks can be described as NaN (Node-Arc-Node) network using two basic geometric types: points (aka <i>nodes</i>) and polylines (aka <i>arcs</i>). NaN topologies can be directed or un-directed, depending on specific type of network (i.e. water networks are directed, while telecommunications networks are not). Such topology structure provides an automated way to handle digitising and editing errors, and enable advanced spatial analyses such as adjacency, connectivity and containment. Infrastructure networks rely on Generic network model developed during Annex I.
  
    Note:
  
    Via the attribute "utilityNetworkType", that uses the "UtilityNetworkTypeValue" codelist, the type of utility network can be defined. E.g. by selecting the "sewer" value, the utility network becomes a "sewer utility network".
  
    Using the "crossTheme" value, a utility network can be created that contains e.g. ducts, which can contain pipes and cables from various utility network types."
    identifier = "Common Utility Network Elements::UtilityNetwork"
    tableName = "US_NET_COMMON_UtilityNetwork"
    id INTEGER NOT NULL PRIMARY KEY
    utilityNetworkType TEXT NOT NULL CHECK(US_NET_COMMON_UtilityNetworkTypeValue)
    ref disclaimer: PT_FreeText[0..*]
    ref elements: NetworkElement[0..*] inv inNetwork[0..*]
  }
  Attributes "US_NET_COMMON_Cabinet" {
    description = "Simple cabinet object which may carry utility objects belonging to either single or multiple utility networks.
  
    Cabinets represent mountable node objects that can contain smaller utility devices and cables."
    identifier = "Common Utility Network Elements::Cabinet"
    tableName = "US_NET_COMMON_Cabinet"
    currentStatus: TEXT [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inspireId: BASE_Identifier[0..1]
  }
  Constraint Enum "US_NET_COMMON_UtilityNetworkTypeValue" {
    identifier = "Common Utility Network Elements::UtilityNetworkTypeValue"
    electricity
    oilGasChemicals
    sewer
    telecommunications [0..1]
    thermal
    water
  }
  Class "UtilityLinkSet" {
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    utilityDeliveryType: TEXT [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    warningType: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
  }
  Attributes "US_NET_COMMON_Pipe" {
    description = "A utility link or link sequence for the conveyance of solids, liquids, chemicals or gases from one location to another.
  
    A pipe can also be used as an object to encase several cables (a bundle of cables) or other (smaller) pipes."
    identifier = "Common Utility Network Elements::Pipe"
    tableName = "US_NET_COMMON_Pipe"
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    pipeDiameter TEXT
    pipeDiameter_uom TEXT CHECK(GML_UomIdentifier)
    pressure TEXT
    pressure_uom TEXT CHECK(GML_UomIdentifier)
    utilityDeliveryType: TEXT [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    warningType: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
  }
  Class "UtilityNodeContainer" {
    currentStatus: TEXT [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inspireId: BASE_Identifier[0..1]
  }
  Attributes "US_NET_COMMON_Pole" {
    description = "Simple pole (mast) object which may carry utility objects belonging to either single or multiple utility networks.
  
    Poles represent node objects that can support utility devices and cables."
    identifier = "Common Utility Network Elements::Pole"
    tableName = "US_NET_COMMON_Pole"
    currentStatus: TEXT [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    poleHeight TEXT
    poleHeight_uom TEXT CHECK(GML_UomIdentifier)
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inspireId: BASE_Identifier[0..1]
  }
  Attributes "US_NET_COMMON_Duct" {
    description = "A utility link or link sequence used to protect and guide cable and pipes via an encasing construction.
  
    A Duct (or Conduit, or Duct-bank, or Wireway) is a linear object which belongs to the structural network. It is the outermost casing. A Duct may contain Pipe(s), Cable(s) or other Duct(s).
  
    Duct is a concrete feature class that contains information about the position and characteristics of ducts as seen from a manhole, vault, or a cross section of a trench and duct."
    identifier = "Common Utility Network Elements::Duct"
    tableName = "US_NET_COMMON_Duct"
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    ductWidth TEXT
    ductWidth_uom TEXT CHECK(GML_UomIdentifier)
    endLifespanVersion: DATETIME [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    utilityDeliveryType: TEXT [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    warningType: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
  }
  Attributes "US_NET_COMMON_UtilityLinkSequence" {
    description = "utility Link Sequence
  
    A linear spatial object, composed of an ordered collection of utility links, which represents a continuous path in the utility network without any branches. The element has a defined beginning and end and every position on the utility link sequence is identifiable with one single parameter."
    identifier = "Common Utility Network Elements::UtilityLinkSequence"
    tableName = "US_NET_COMMON_UtilityLinkSequence"
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
    ref link: NET_DirectedLink[1..*]
  }
  Attributes "US_NET_COMMON_Tower" {
    description = "Simple tower object which may carry utility objects belonging to either single or multiple utility networks.
  
    Towers represent node objects that support reservoirs, cables or antennas."
    identifier = "Common Utility Network Elements::Tower"
    tableName = "US_NET_COMMON_Tower"
    currentStatus: TEXT [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    towerHeight TEXT
    towerHeight_uom TEXT CHECK(GML_UomIdentifier)
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inspireId: BASE_Identifier[0..1]
  }
  Class "Cable" {
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    utilityDeliveryType: TEXT [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    warningType: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
  }
  Class "UtilityNetworkElement" {
    currentStatus: TEXT [0..1]
    governmentalServiceReference: GovernmentalService [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
  }
  Constraint Enum "US_NET_COMMON_UtilityDeliveryTypeValue" {
    identifier = "Common Utility Network Elements::UtilityDeliveryTypeValue"
    collection
    distribution
    private
    transport
  }
  Class "UtilityNode" {
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
    ref spokeEnd: Link[0..*] inv endNode[0..1]
    ref spokeStart: Link[0..*] inv startNode[0..1]
  }
  Attributes "US_NET_COMMON_Manhole" {
    description = "Simple container object which may contain either single or multiple utility networks objects.
  
    Manholes perform following functions:
  
    <ul>
  
    <li>Provide drainage for the conduit system so that freezing water does not damage the conduit or wires. </li>
  
    <li>Provide a location for bending the conduit run without damaging the wires. </li>
  
    <li>Provide a junction for conduits coming from different directions. </li>
  
    <li>Provide access to the system for maintenance. </li>
  
    </ul>"
    identifier = "Common Utility Network Elements::Manhole"
    tableName = "US_NET_COMMON_Manhole"
    currentStatus: TEXT [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inspireId: BASE_Identifier[0..1]
  }
  Constraint Enum "US_NET_COMMON_AppurtenanceTypeValue" {
    identifier = "Common Utility Network Elements::AppurtenanceTypeValue"
  }
  Attributes "US_NET_COMMON_Appurtenance" {
    description = "An appurtenance is a node object that is described by its type (via the attribute "appurtenanceType").
  
    The "appurtenanceType" attribute uses the "AppurtenanceTypeValue" codelist for its values. But this is an empty codelist that needs to be extended by a concrete codelist of appurtenance types for each utility network type.
  
    So e.g. for the electricity network, the "ElectricityAppurtenanceTypeValue" codelist should be used."
    identifier = "Common Utility Network Elements::Appurtenance"
    tableName = "US_NET_COMMON_Appurtenance"
    appurtenanceType TEXT CHECK(US_NET_COMMON_AppurtenanceTypeValue)
    beginLifespanVersion: DATETIME [0..1]
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    geometry: POINT
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    specificAppurtenanceType TEXT CHECK(US_NET_COMMON_SpecificAppurtenanceTypeValue)
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
    ref spokeEnd: Link[0..*] inv endNode[0..1]
    ref spokeStart: Link[0..*] inv startNode[0..1]
  }
  Attributes "US_NET_COMMON_UtilityLink" {
    description = "utility Link
  
    A linear spatial object that describes the geometry and connectivity of a utility network between two points in the network."
    identifier = "Common Utility Network Elements::UtilityLink"
    tableName = "US_NET_COMMON_UtilityLink"
    beginLifespanVersion: DATETIME [0..1]
    centrelineGeometry: CURVE
    currentStatus: TEXT [0..1]
    endLifespanVersion: DATETIME [0..1]
    fictitious: BOOLEAN
    governmentalServiceReference: GovernmentalService [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    utilityFacilityReference: ACT_CORE_ActivityComplex [0..1]
    validFrom: DATETIME [0..1]
    validTo: DATETIME [0..1]
    verticalPosition: TEXT [0..1]
    ref endNode: Node[0..1] inv spokeEnd[0..*]
    ref inNetwork: NET_Network[0..*] inv elements[0..*]
    ref inspireId: BASE_Identifier[0..1]
    ref startNode: Node[0..1] inv spokeStart[0..*]
  }
  Constraint Enum "US_NET_COMMON_SpecificAppurtenanceTypeValue" {
    identifier = "Common Utility Network Elements::SpecificAppurtenanceTypeValue"
  }
  Constraint Enum "US_NET_COMMON_WarningTypeValue" {
    identifier = "Common Utility Network Elements::WarningTypeValue"
    concretePaving
    net
    tape
  }
  Relation "US_NET_COMMON_UtilityNetwork_networks" {
    profile = "attributes"
    tableName = "US_NET_COMMON_UtilityNetwork_networks"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_UtilityNetwork(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES US_NET_COMMON_UtilityNetwork(id)
  }
  Relation "US_NET_COMMON_UtilityNetwork_authorityRole" {
    profile = "attributes"
    tableName = "US_NET_COMMON_UtilityNetwork_authorityRole"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_UtilityNetwork(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE2_RelatedParty(id)
  }
  Relation "US_NET_COMMON_UtilityNetwork_utilityFacilityReference" {
    profile = "features"
    tableName = "US_NET_COMMON_UtilityNetwork_utilityFacilityReference"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_UtilityNetwork(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES ACT_CORE_ActivityComplex(id)
  }
  Relation "US_NET_COMMON_Pipe_pipes" {
    profile = "attributes"
    tableName = "US_NET_COMMON_Pipe_pipes"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_Pipe(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES US_NET_COMMON_Pipe(id)
  }
  Relation "US_NET_COMMON_Duct_pipes" {
    profile = "attributes"
    tableName = "US_NET_COMMON_Duct_pipes"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_Duct(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES US_NET_COMMON_Pipe(id)
  }
  Relation "US_NET_COMMON_Duct_ducts" {
    profile = "attributes"
    tableName = "US_NET_COMMON_Duct_ducts"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES US_NET_COMMON_Duct(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES US_NET_COMMON_Duct(id)
  }
  Metadata "Unknown" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attribute"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Unpopulated" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attributeType"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Withheld" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attribute"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Withheld" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attributeType"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Relation "NET_Network_geographicalName" {
    profile = "attributes"
    tableName = "NET_Network_geographicalName"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES NET_Network(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "BASE2_RelatedParty_contact" {
    profile = "attributes"
    relatedReference = "BASE2_RelatedParty#contact"
    tableName = "BASE2_RelatedParty_contact"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES BASE2_RelatedParty(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE2_Contact(id)
  }
  Relation "BASE2_RelatedParty_role" {
    profile = "attributes"
    tableName = "BASE2_RelatedParty_role"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES BASE2_RelatedParty(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE2_PartyRoleValue(id)
  }
  Relation "ACT_CORE_ActivityComplex_inspireId" {
    profile = "attributes"
    relatedReference = "ACT_CORE_ActivityComplex#inspireId"
    tableName = "ACT_CORE_ActivityComplex_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_ActivityComplex(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "ACT_CORE_ActivityComplex_thematicId" {
    profile = "attributes"
    tableName = "ACT_CORE_ActivityComplex_thematicId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_ActivityComplex(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE2_ThematicIdentifier(id)
  }
  Relation "ACT_CORE_ActivityComplex_function" {
    profile = "attributes"
    tableName = "ACT_CORE_ActivityComplex_function"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_ActivityComplex(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES ACT_CORE_Function(id)
  }
  Relation "GN_GeographicalName_spelling" {
    profile = "attributes"
    tableName = "GN_GeographicalName_spelling"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_GeographicalName(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_SpellingOfName(id)
  }
  Relation "AU_admUnit_boundary" {
    profile = "features"
    tableName = "AU_admUnit_boundary"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeBoundary(id)
  }
  Relation "AU_AdministrativeUnit_administeredBy" {
    profile = "features"
    tableName = "AU_AdministrativeUnit_administeredBy"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeUnit(id)
  }
  Relation "AU_AdministrativeUnit_lowerLevelUnit" {
    profile = "features"
    relatedReference = "AU_AdministrativeUnit#upperLevelUnit"
    tableName = "AU_AdministrativeUnit_lowerLevelUnit"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeUnit(id)
  }
  Relation "AU_AdministrativeUnit_inspireId" {
    profile = "attributes"
    relatedReference = "AU_AdministrativeUnit#inspireId"
    tableName = "AU_AdministrativeUnit_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "AU_AdministrativeUnit_name" {
    profile = "attributes"
    tableName = "AU_AdministrativeUnit_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AU_AdministrativeUnit_nationalLevelName" {
    profile = "attributes"
    tableName = "AU_AdministrativeUnit_nationalLevelName"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_LocalisedCharacterString(id)
  }
  Relation "AU_AdministrativeUnit_residenceOfAuthority" {
    profile = "features"
    tableName = "AU_AdministrativeUnit_residenceOfAuthority"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_ResidenceOfAuthority(id)
  }
  Relation "GN_NamedPlace_inspireId" {
    profile = "attributes"
    relatedReference = "GN_NamedPlace#inspireId"
    tableName = "GN_NamedPlace_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_NamedPlace(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "GN_NamedPlace_localType" {
    profile = "attributes"
    tableName = "GN_NamedPlace_localType"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_NamedPlace(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_LocalisedCharacterString(id)
  }
  Relation "GN_NamedPlace_name" {
    profile = "attributes"
    tableName = "GN_NamedPlace_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_NamedPlace(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "GN_NamedPlace_relatedSpatialObject" {
    profile = "attributes"
    tableName = "GN_NamedPlace_relatedSpatialObject"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_NamedPlace(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "GN_NamedPlace_type" {
    profile = "attributes"
    tableName = "GN_NamedPlace_type"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GN_NamedPlace(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_NamedPlaceTypeValue(id)
  }
  Relation "BASE2_Contact_address" {
    profile = "attributes"
    relatedReference = "BASE2_Contact#address"
    tableName = "BASE2_Contact_address"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES BASE2_Contact(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_AddressRepresentation(id)
  }
  Relation "ACT_CORE_Function_activity" {
    profile = "attributes"
    tableName = "ACT_CORE_Function_activity"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_Function(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES ACT_CORE_EconomicActivityValue(id)
  }
  Relation "ACT_CORE_Function_input" {
    profile = "attributes"
    tableName = "ACT_CORE_Function_input"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_Function(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES ACT_CORE_InputOutputValue(id)
  }
  Relation "ACT_CORE_Function_output" {
    profile = "attributes"
    tableName = "ACT_CORE_Function_output"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES ACT_CORE_Function(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES ACT_CORE_InputOutputValue(id)
  }
  Relation "AD_Address_parentAddress" {
    profile = "attributes"
    relatedReference = "AD_Address#parentAddress"
    tableName = "AD_Address_parentAddress"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_Address(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_Address(id)
  }
  Relation "AD_Address_inspireId" {
    profile = "attributes"
    relatedReference = "AD_Address#inspireId"
    tableName = "AD_Address_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_Address(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "AD_Address_locator" {
    profile = "attributes"
    tableName = "AD_Address_locator"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_Address(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_AddressLocator(id)
  }
  Relation "AD_Address_position" {
    profile = "features"
    tableName = "AD_Address_position"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_Address(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_GeographicPosition(id)
  }
  Relation "AU_AdministrativeBoundary_inspireId" {
    profile = "attributes"
    relatedReference = "AU_AdministrativeBoundary#inspireId"
    tableName = "AU_AdministrativeBoundary_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeBoundary(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "AU_AdministrativeBoundary_nationalLevel" {
    profile = "attributes"
    tableName = "AU_AdministrativeBoundary_nationalLevel"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_AdministrativeBoundary(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeHierarchyLevel(id)
  }
  Relation "AU_Condominium_admUnit" {
    profile = "features"
    tableName = "AU_Condominium_admUnit"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_Condominium(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeUnit(id)
  }
  Relation "AU_Condominium_inspireId" {
    profile = "attributes"
    relatedReference = "AU_Condominium#inspireId"
    tableName = "AU_Condominium_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_Condominium(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "AU_Condominium_name" {
    profile = "attributes"
    tableName = "AU_Condominium_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_Condominium(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AU_ResidenceOfAuthority_name" {
    profile = "attributes"
    relatedReference = "AU_ResidenceOfAuthority#name"
    tableName = "AU_ResidenceOfAuthority_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AU_ResidenceOfAuthority(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressRepresentation_addressFeature" {
    profile = "attributes"
    relatedReference = "AD_AddressRepresentation#addressFeature"
    tableName = "AD_AddressRepresentation_addressFeature"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_Address(id)
  }
  Relation "AD_AddressRepresentation_adminUnit" {
    profile = "attributes"
    tableName = "AD_AddressRepresentation_adminUnit"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressRepresentation_locatorName" {
    profile = "attributes"
    tableName = "AD_AddressRepresentation_locatorName"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressRepresentation_addressArea" {
    profile = "attributes"
    tableName = "AD_AddressRepresentation_addressArea"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressRepresentation_postName" {
    profile = "attributes"
    tableName = "AD_AddressRepresentation_postName"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressRepresentation_thoroughfare" {
    profile = "attributes"
    tableName = "AD_AddressRepresentation_thoroughfare"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressRepresentation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Relation "AD_AddressLocator_designator" {
    profile = "attributes"
    tableName = "AD_AddressLocator_designator"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressLocator(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_LocatorDesignator(id)
  }
  Relation "AD_AddressLocator_name" {
    profile = "attributes"
    tableName = "AD_AddressLocator_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_AddressLocator(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AD_LocatorName(id)
  }
  Relation "CP_BasicPropertyUnit_administrativeUnit" {
    profile = "features"
    relatedReference = "CP_BasicPropertyUnit#administrativeUnit"
    tableName = "CP_BasicPropertyUnit_administrativeUnit"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES CP_BasicPropertyUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES AU_AdministrativeUnit(id)
  }
  Relation "CP_BasicPropertyUnit_inspireId" {
    profile = "attributes"
    relatedReference = "CP_BasicPropertyUnit#inspireId"
    tableName = "CP_BasicPropertyUnit_inspireId"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES CP_BasicPropertyUnit(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES BASE_Identifier(id)
  }
  Relation "AD_LocatorName_name" {
    profile = "attributes"
    tableName = "AD_LocatorName_name"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES AD_LocatorName(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GN_GeographicalName(id)
  }
  Constraint Enum "BASE_ConditionOfFacilityValue" {
    identifier = "Base Types::ConditionOfFacilityValue"
    decommissioned
    disused
    functional
    projected
    underConstruction
  }
  Constraint Enum "BASE_VerticalPositionValue" {
    identifier = "Base Types::VerticalPositionValue"
    onGroundSurface
    suspendedOrElevated
    underground
  }
  Constraint Enum "GML_UomIdentifier" {}
  Attributes "BASE_Identifier" {
    description = "External unique object identifier published by the responsible body, which may be used by external applications to reference the spatial object.
  
    NOTE1 External object identifiers are distinct from thematic object identifiers.
  
    NOTE 2 The voidable version identifier attribute is not part of the unique identifier of a spatial object and may be used to distinguish two versions of the same spatial object.
  
    NOTE 3 The unique identifier will not change during the life-time of a spatial object."
    identifier = "Base Types::Identifier"
    tableName = "BASE_Identifier"
    id INTEGER NOT NULL PRIMARY KEY
    localId TEXT NOT NULL
    namespace TEXT NOT NULL
    versionId TEXT
  }
  Feature "ACT_CORE_ActivityComplex" {
    description = "A "single unit", both technically and economically, under the management control of the same legal entity (operator), covering activities as those listed in the Eurostat NACE classification, products and services. Activity Complex includes all infrastructure, equipment and materials. It must represent the whole area, at the same or different geographical location, managed by a "single unit".
  
    NOTE 1 This class describes the minimal set of elements necessary to describe and identify geographically a legal entity and the activities taken place on it under the context of a Environmental purposes.
  
    NOTE 2 "Activity Complex" could be assimilated to terms described on the legislation as Facility, Establishment, Plant, Holding, Organization ,Farm, Extractive Industries or Aquaculture Production Business among others
  
    EXAMPLE i.e. an Agro-business that is legally registered under the Emissions Directive."
    identifier = "Activity Complex::ActivityComplex"
    tableName = "ACT_CORE_ActivityComplex"
    beginLifespanVersion DATETIME
    endLifespanVersion DATETIME
    geometry GEOMETRY NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    name TEXT
    validFrom DATETIME
    validTo DATETIME
  }
  Attributes "NET_Network" {
    description = "A network is a collection of network elements.
  
    The reason for collecting certain elements in a certain network may vary (e.g. connected elements for the same mode of transport)"
    identifier = "Network::Network"
    tableName = "NET_Network"
    id INTEGER NOT NULL PRIMARY KEY
    ref elements: NetworkElement[0..*] inv inNetwork[0..*]
  }
  Attributes "NET_DirectedLink" {
    description = "A link either in its positive or negative direction."
    identifier = "Network::DirectedLink"
    tableName = "NET_DirectedLink"
    direction TEXT NOT NULL CHECK(GML_Sign)
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "BASE2_RelatedParty" {
    description = "An organisation or a person with a role related to a resource.
  
    NOTE 1 A party, typically an individual person, acting as a general point of contact for a resource can be specified without providing any particular role."
    identifier = "Base Types 2::RelatedParty"
    tableName = "BASE2_RelatedParty"
    contact INTEGER
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "GN_GeographicalName" {
    description = "Proper noun applied to a real world entity."
    identifier = "Geographical Names::GeographicalName"
    tableName = "GN_GeographicalName"
    grammaticalGender TEXT CHECK(GN_GrammaticalGenderValue)
    grammaticalNumber TEXT CHECK(GN_GrammaticalNumberValue)
    id INTEGER NOT NULL PRIMARY KEY
    language TEXT
    nameStatus TEXT CHECK(GN_NameStatusValue)
    nativeness TEXT CHECK(GN_NativenessValue)
    pronunciation_pronunciationIPA TEXT
    pronunciation_pronunciationSoundLink TEXT
    sourceOfName TEXT
  }
  Attributes "BASE2_Contact" {
    description = "Communication channels by which it is possible to gain access to someone or something."
    identifier = "Base Types 2::Contact"
    tableName = "BASE2_Contact"
    address INTEGER
    electronicMailAddress TEXT
    id INTEGER NOT NULL PRIMARY KEY
    ref telephoneFacsimile: TEXT[0..*]
    ref telephoneVoice: TEXT[0..*]
  }
  Attributes "BASE2_PartyRoleValue" {
    description = "Roles of parties related to or responsible for a resource."
    identifier = "Base Types 2::PartyRoleValue"
    tableName = "BASE2_PartyRoleValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(BASE2_PartyRoleValue)
  }
  Attributes "BASE2_ThematicIdentifier" {
    description = "Thematic identifier to uniquely identify the spatial object.
  
    Some spatial objects may be assigned multiple unique identifiers.
  
    These may have been established to meet data exchange requirements of different reporting obligations at International, European or national levels and/or internal data maintenance requirements."
    identifier = "Base Types 2::ThematicIdentifier"
    tableName = "BASE2_ThematicIdentifier"
    id INTEGER NOT NULL PRIMARY KEY
    identifier TEXT NOT NULL
    identifierScheme TEXT NOT NULL
  }
  Attributes "ACT_CORE_Function" {
    description = "The function of something expressed as an activity and optional input and/or output.
  
    NOTE  Depending on the scope it can refer to different activities (co-incineration, Collection, exploration, incineration, interim disposal, management, recycling, primary production, primary treatment, recovery , recycling, release, storage, use, waste management, etc) and Inputs and Outputs (sludge, substance, tailings, technical products, urban waste water, volatile organic compound, waste, WEEE from private households, etc)."
    identifier = "Activity Complex::Function"
    tableName = "ACT_CORE_Function"
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "GN_SpellingOfName" {
    description = "Proper way of writing a name.
  
    SOURCE Adapted from [UNGEGN Manual 2006].
  
    NOTE Proper spelling means the writing of a name with the correct capitalisation and the correct letters and diacritics present in an accepted standard order."
    identifier = "Geographical Names::SpellingOfName"
    tableName = "GN_SpellingOfName"
    id INTEGER NOT NULL PRIMARY KEY
    script TEXT
    text TEXT NOT NULL
    transliterationScheme TEXT
  }
  Feature "AU_AdministrativeUnit" {
    description = "Unit of administration where a Member State has and/or exercises jurisdictional rights, for local, regional and national governance."
    identifier = "AdministrativeUnits::AdministrativeUnit"
    tableName = "AU_AdministrativeUnit"
    beginLifespanVersion DATETIME
    country TEXT NOT NULL CHECK(BASE2_CountryCode)
    endLifespanVersion DATETIME
    geometry MULTISURFACE NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    nationalCode TEXT NOT NULL
    nationalLevel TEXT NOT NULL CHECK(AU_AdministrativeHierarchyLevel)
    upperLevelUnit INTEGER
  }
  Feature "AU_AdministrativeBoundary" {
    description = "A line of demarcation between administrative units."
    identifier = "AdministrativeUnits::AdministrativeBoundary"
    tableName = "AU_AdministrativeBoundary"
    beginLifespanVersion DATETIME
    country TEXT NOT NULL CHECK(BASE2_CountryCode)
    endLifespanVersion DATETIME
    geometry CURVE NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    legalStatus TEXT CHECK(AU_LegalStatusValue) DEFAULT 'agreed'
    technicalStatus TEXT CHECK(AU_TechnicalStatusValue) DEFAULT 'edgeMatched'
  }
  Attributes "GMD_LocalisedCharacterString" {
    identifier = "Cultural and linguistic adapdability::LocalisedCharacterString"
    tableName = "GMD_LocalisedCharacterString"
    characterSetCode TEXT CHECK(GMD_MD_CharacterSetCode)
    country TEXT CHECK(GMD_CountryCode)
    id INTEGER NOT NULL PRIMARY KEY
    languageCode TEXT NOT NULL CHECK(GMD_LanguageCode)
    text TEXT NOT NULL
  }
  Feature "AU_ResidenceOfAuthority" {
    description = "Data type representing the name and position of a residence of authority."
    identifier = "AdministrativeUnits::ResidenceOfAuthority"
    tableName = "AU_ResidenceOfAuthority"
    geometry POINT
    id INTEGER NOT NULL PRIMARY KEY
    name INTEGER
  }
  Feature "GN_NamedPlace" {
    description = "Any real world entity referred to by one or several proper nouns."
    identifier = "Geographical Names::NamedPlace"
    tableName = "GN_NamedPlace"
    beginLifespanVersion DATETIME
    endLifespanVersion DATETIME
    geometry GEOMETRY NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    leastDetailedViewingResolution_distance TEXT
    leastDetailedViewingResolution_distance_uom TEXT CHECK(GML_UomIdentifier)
    leastDetailedViewingResolution_equivalentScale_denominator INTEGER
    mostDetailedViewingResolution_distance TEXT
    mostDetailedViewingResolution_distance_uom TEXT CHECK(GML_UomIdentifier)
    mostDetailedViewingResolution_equivalentScale_denominator INTEGER
  }
  Attributes "GN_NamedPlaceTypeValue" {
    description = "The type of a named place."
    identifier = "Geographical Names::NamedPlaceTypeValue"
    tableName = "GN_NamedPlaceTypeValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(GN_NamedPlaceTypeValue)
  }
  Attributes "AD_AddressRepresentation" {
    description = "Representation of an address spatial object for use in external application schemas that need to include the basic, address information in a readable way.
  
    NOTE 1 The data type includes the all necessary readable address components as well as the address locator(s), which allows the identification of the address spatial objects, e.g., country, region, municipality, address area, post code, street name and address number. It also includes an optional reference to the full address spatial object.
  
    NOTE 2 The datatype could be used in application schemas that wish to include address information e.g. in a dataset that registers buildings or properties."
    identifier = "Addresses::AddressRepresentation"
    tableName = "AD_AddressRepresentation"
    addressFeature INTEGER
    id INTEGER NOT NULL PRIMARY KEY
    postCode TEXT
    ref locatorDesignator: TEXT[0..*]
  }
  Attributes "ACT_CORE_EconomicActivityValue" {
    description = "Classification of economic activities."
    identifier = "Activity Complex::EconomicActivityValue"
    tableName = "ACT_CORE_EconomicActivityValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(ACT_CORE_EconomicActivityValue)
  }
  Attributes "ACT_CORE_InputOutputValue" {
    description = "Classification of inputs or outputs."
    identifier = "Activity Complex::InputOutputValue"
    tableName = "ACT_CORE_InputOutputValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(ACT_CORE_InputOutputValue)
  }
  Attributes "ACT_CORE_InputOutputValue" {
    description = "Classification of inputs or outputs."
    identifier = "Activity Complex::InputOutputValue"
    tableName = "ACT_CORE_InputOutputValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(ACT_CORE_InputOutputValue)
  }
  Attributes "AD_Address" {
    description = "An identification of the fixed location of property by means of a structured composition of geographic names and identifiers.
  
    NOTE 1 The spatial object, referenced by the address, is defined as the "addressable object". The addressable object is not within the application schema, but it is possible to represent the address' reference to a cadastral parcel or a building through associations. It should, however, be noted that in different countries and regions, different traditions and/or regulations determine which object types should be regarded as addressable objects.
  
    NOTE 2 In most situations the addressable objects are current, real world objects. However, addresses may also reference objects which are planned, under construction or even historical.
  
    NOTE 3 Apart from the identification of the addressable objects (like e.g. buildings), addresses are very often used by a large number of other applications to identify object types e.g. statistics of the citizens living in the building, for taxation of the business entities that occupy the building, and the utility installations.
  
    NOTE 4 For different purposes, the identification of an address can be represented in different ways (see example 3).
  
    EXAMPLE 1 A property can e.g., be a plot of land, building, part of building, way of access or other construction,
  
    EXAMPLE 2 In the Netherlands the primary addressable objects are buildings and dwellings which may include parts of buildings, mooring places or places for the permanent placement of trailers (mobile homes), in the UK it is the lowest level of unit for the delivery of services, in the Czech Republic it is buildings and entrance doors.
  
    EXAMPLE 3 Addresses can be represented differently. In a human readable form an address in Spain and an address in Denmark could be represented like this: "Calle Mayor, 13, Cortijo del Marqués, 41037 Écija, Sevilla, España" or "Wildersgade 60A, st. th, 1408 Copenhagen K., Denmark"."
    identifier = "Addresses::Address"
    tableName = "AD_Address"
    alternativeIdentifier TEXT
    beginLifespanVersion DATETIME
    endLifespanVersion DATETIME
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    parentAddress INTEGER
    status TEXT CHECK(AD_StatusValue)
    validFrom DATETIME
    validTo DATETIME
  }
  Attributes "AD_AddressLocator" {
    description = "Human readable designator or name that allows a user or application to reference and distinguish the address from neighbour addresses, within the scope of a thoroughfare name, address area name, administrative unit name or postal designator, in which the address is situated.
  
    NOTE 1 The most common locators are designators like an address number, building number or flat identifier as well as the name of the property, complex or building.
  
    NOTE 2 The locator identifier(s) are most often only unambiguous and meaningful within the scope of the adjacent thoroughfare name, address area name or post code.
  
    NOTE 3 The locator could be composed of one or more designators e.g., address number, address number suffix, building number or name, floor number, flat or room identifier. In addition to these common locator types, also narrative or descriptive locators are possible.
  
    NOTE 4 The locators of an address could be composed as a hierarchy, where one level of locators identifies the real property or building while another level of locators identifies the flats or dwellings inside the property.
  
    EXAMPLE 1 In a Spanish city a "site-level" locator could identify a building on the thoroughfare name "Calle Gran Vía using the address number "8". If the building has four entrance doors, the door number "3" could be the "access-level" locator. The 3rd door could, via two staircases "A" and "B", give access to a number of floors, identified by a number "1" to "5" on which a number of dwellings are situated, also identified by numbers "1" to "3"; The "unit level" locator will thus composed of staircase-, floor- and dwelling identification e.g. "staircase A, floor 5, dwelling 1". In total, the three parent-child levels of locators uniquely identify the dwelling.
  
    EXAMPLE 2 In Copenhagen an "access level" locator could identify a specific entrance door in a building on the thoroughfare name "Wildersgade" using the address number "60A" (In Denmark the optional suffix is a part of the address number). The entrance door gives access to a number of floors, e.g, "st", "1", "2", "3", on which two dwellings are situated "tv" and "th". The "unit level" locator will thus be composed by a floor- and a door identifier: "2. th." (2nd floor, door to the right). In total, the two parent-child levels of locators uniquely identify the dwelling.
  
    EXAMPLE 3 In The Netherlands only one level of locators exists. The individual apartment within a large complex, a dwelling, a part of other kinds of buildings (for example an office), a mooring place or a place for the permanent placing of trailers are addressable objects which must have an address. This address is the only level of the locator. This locator could be composed by three attributes the house number, plus optionally an additional house letter, plus optionally an additional housenumber suffix.
  
    EXAMPLE 4 Sometimes the building name is an alternative identifier to the address number e.g. the house located in "Calle Santiago, 15, Elizondo-Baztán, Navarra, Spain" is also identified by the building name "Urtekoetxea""
    identifier = "Addresses::AddressLocator"
    tableName = "AD_AddressLocator"
    id INTEGER NOT NULL PRIMARY KEY
    level TEXT NOT NULL CHECK(AD_LocatorLevelValue)
  }
  Feature "AD_GeographicPosition" {
    description = "The position of a characteristic point which represents the location of the address according to a certain specification, including information on the origin of the position."
    identifier = "Addresses::GeographicPosition"
    tableName = "AD_GeographicPosition"
    default BOOLEAN NOT NULL
    geometry POINT NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    method TEXT CHECK(AD_GeometryMethodValue)
    specification TEXT CHECK(AD_GeometrySpecificationValue)
  }
  Attributes "AU_AdministrativeHierarchyLevel" {
    description = "Levels of administration in the national administrative hierarchy. This code list reflects the level in the hierarchical pyramid of the administrative structures, which is based on geometric aggregation of territories and does not necessarily describe the subordination between the related administrative authorities."
    identifier = "AdministrativeUnits::AdministrativeHierarchyLevel"
    tableName = "AU_AdministrativeHierarchyLevel"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(AU_AdministrativeHierarchyLevel)
  }
  Feature "AU_Condominium" {
    description = "An administrative area established independently to any national administrative division of territory  and administered by two or more countries.
  
    NOTE Condominium is not a part of any national administrative hierarchy of territory division in Member State."
    identifier = "AdministrativeUnits::Condominium"
    tableName = "AU_Condominium"
    beginLifespanVersion DATETIME
    endLifespanVersion DATETIME
    geometry MULTISURFACE NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
  }
  Attributes "AD_LocatorDesignator" {
    description = "A number or a sequence of characters that uniquely identifies the locator within the relevant scope(s). The full identification of the locator could include one or more locator designators.
  
    NOTE 1 Locator designators are often assigned according to a set of commonly known rules which enables a user or application to "parse" the information: Address numbers are most often assigned in ascending order with odd and even numbers on each side of the thoroughfare. In a building, the floor identifier represents the level according to the traditions within the area, e.g., 1, 2, 3.
  
    NOTE 2 Several types of locator designators exist, such as: Address number, address number suffix, building identifier, building name. A locator could be composed by an ordered set of these.
  
    EXAMPLE In Paris, France a locator could be composed by two locator designators: address number "18" and address number suffix: "BIS"."
    identifier = "Addresses::LocatorDesignator"
    tableName = "AD_LocatorDesignator"
    designator TEXT NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    type TEXT NOT NULL CHECK(AD_LocatorDesignatorTypeValue)
  }
  Attributes "AD_LocatorName" {
    description = "Proper noun applied to the real world entity identified by the locator.
  
    NOTE The locator name could be the name of the property or complex, of the building or part of the building, or it could be the name of a room inside a building."
    identifier = "Addresses::LocatorName"
    tableName = "AD_LocatorName"
    id INTEGER NOT NULL PRIMARY KEY
    type TEXT NOT NULL CHECK(AD_LocatorNameTypeValue)
  }
  Attributes "CP_BasicPropertyUnit" {
    description = "The basic unit of ownership that is recorded in the land books, land registers or equivalent. It is defined by unique ownership and homogeneous real property rights, and may consist of one or more adjacent or geographically separate parcels.
  
    SOURCE Adapted from UN ECE 2004.
  
    NOTE 1 In the INSPIRE context, basic property units are to be made available by member states where unique cadastral references are given only for basic property units and not for parcels.
  
    NOTE 2 In many (but not all) countries, the area of the basic property unit corresponds to the cadastral parcel itself.
  
    NOTE 3 Some countries, such as Finland, may also register officially basic property units without any area. These basic property units are considered out of the INSPIRE scope.
  
    NOTE 4 Some countries, such as Norway, may have parcels which belong to several basic property units."
    identifier = "CadastralParcels::BasicPropertyUnit"
    tableName = "CP_BasicPropertyUnit"
    administrativeUnit INTEGER
    areaValue TEXT
    areaValue_uom TEXT CHECK(GML_UomIdentifier)
    beginLifespanVersion DATETIME
    endLifespanVersion DATETIME
    id INTEGER NOT NULL PRIMARY KEY
    inspireId INTEGER
    nationalCadastralReference TEXT NOT NULL
    validFrom DATETIME
    validTo DATETIME
  }
  Feature "BU_CORE2D_Building" {
    description = "A Building is an enclosed construction above and/or underground, used or intended for the shelter of humans, animals or things or for the production of economic goods. A building refers to any structure permanently constructed or erected on its site."
    identifier = "Buildings2D::Building"
    tableName = "BU_CORE2D_Building"
    beginLifespanVersion: DATETIME [0..1]
    buildingNature: TEXT [0..*]
    conditionOfConstruction: TEXT [0..1]
    dateOfConstruction_anyPoint: DATETIME [0..1]
    dateOfConstruction_beginning: DATETIME [0..1]
    dateOfConstruction_end: DATETIME [0..1]
    dateOfDemolition_anyPoint: DATETIME [0..1]
    dateOfDemolition_beginning: DATETIME [0..1]
    dateOfDemolition_end: DATETIME [0..1]
    dateOfRenovation_anyPoint: DATETIME [0..1]
    dateOfRenovation_beginning: DATETIME [0..1]
    dateOfRenovation_end: DATETIME [0..1]
    endLifespanVersion: DATETIME [0..1]
    geometry2D_geometry GEOMETRY NOT NULL
    geometry2D_horizontalGeometryEstimatedAccuracy TEXT
    geometry2D_horizontalGeometryEstimatedAccuracy_uom TEXT CHECK(GML_UomIdentifier)
    geometry2D_horizontalGeometryReference TEXT NOT NULL CHECK(BU_BASE_HorizontalGeometryReferenceValue)
    geometry2D_referenceGeometry BOOLEAN NOT NULL
    geometry2D_verticalGeometryEstimatedAccuracy TEXT
    geometry2D_verticalGeometryEstimatedAccuracy_uom TEXT CHECK(GML_UomIdentifier)
    geometry2D_verticalGeometryReference TEXT CHECK(BU_BASE_ElevationReferenceValue)
    id INTEGER NOT NULL PRIMARY KEY
    numberOfBuildingUnits: INTEGER [0..1]
    numberOfDwellings: INTEGER [0..1]
    numberOfFloorsAboveGround: INTEGER [0..1]
    ref currentUse: BU_BASE_CurrentUse[0..*]
    ref elevation: BU_BASE_Elevation[0..*]
    ref externalReference: BU_BASE_ExternalReference[0..*]
    ref heightAboveGround: BU_BASE_HeightAboveGround[0..*]
    ref inspireId: BASE_Identifier
    ref name: GN_GeographicalName[0..*]
    ref ProductionBuilding inv building[0..*]
  }
  Constraint Enum "US_GOVSERV_ServiceTypeValue" {
    identifier = "AdministrativeAndSocialGovernmentalServices::ServiceTypeValue"
  }
  Constraint Enum "GML_Sign" {
    identifier = "basicTypes::Sign"
    "+"
    "-"
  }
  Constraint Enum "GN_NativenessValue" {
    identifier = "Geographical Names::NativenessValue"
    endonym
    exonym
  }
  Constraint Enum "GN_NameStatusValue" {
    identifier = "Geographical Names::NameStatusValue"
    historical
    official
    other
    standardised
  }
  Constraint Enum "GN_GrammaticalGenderValue" {
    identifier = "Geographical Names::GrammaticalGenderValue"
    common
    feminine
    masculine
    neuter
  }
  Constraint Enum "GN_GrammaticalNumberValue" {
    identifier = "Geographical Names::GrammaticalNumberValue"
    dual
    plural
    singular
  }
  Constraint Enum "BASE2_PartyRoleValue" {
    identifier = "Base Types 2::PartyRoleValue"
  }
  Constraint Enum "BASE2_CountryCode" {
    identifier = "Base Types 2::CountryCode"
    AT
    BE
    BG
    CY
    CZ
    DE
    DK
    EE
    EL
    ES
    FI
    FR
    HR
    HU
    IE
    IT
    LT
    LU
    LV
    MT
    NL
    PL
    PT
    RO
    SE
    SI
    SK
    TR
    UK
  }
  Constraint Enum "AU_AdministrativeHierarchyLevel" {
    identifier = "AdministrativeUnits::AdministrativeHierarchyLevel"
    1stOrder
    2ndOrder
    3rdOrder
    4thOrder
    5thOrder
    6thOrder
  }
  Constraint Enum "AU_LegalStatusValue" {
    identifier = "AdministrativeUnits::LegalStatusValue"
    agreed
    notAgreed
  }
  Constraint Enum "AU_TechnicalStatusValue" {
    identifier = "AdministrativeUnits::TechnicalStatusValue"
    edgeMatched
    notEdgeMatched
  }
  Constraint Enum "GMD_LanguageCode" {
    identifier = "ISO 00639 Language Codes::LanguageCode"
    Afrikaans
    Albanian
    Arabic
    Basque
    Belarusian
    Bulgarian
    Catalan
    Chinese
    Croatian
    Czech
    Danish
    Dutch
    English
    Estonian
    Faeroese
    Finnish
    French
    French(Canadian)
    German
    Greek
    Hawaian
    Hebrew
    Hungarian
    Icelandic
    Indonesian
    Italian
    Japanese
    Korean
    Latvian
    Lithuanian
    Malaysian
    Norwegian
    Polish
    Portuguese
    Romanian
    Russian
    Serbian
    Slovak
    Slovenian
    Spanish
    Swahili
    Swedish
    Turkish
    Ukranian
  }
  Constraint Enum "GMD_CountryCode" {
    identifier = "ISO 03166 Country Codes::CountryCode"
  }
  Constraint Enum "GMD_MD_CharacterSetCode" {
    identifier = "Identification information::MD_CharacterSetCode"
    (reservedforfutureuse)
    8859part1
    8859part10
    8859part11
    8859part13
    8859part14
    8859part15
    8859part16
    8859part2
    8859part3
    8859part4
    8859part5
    8859part6
    8859part7
    8859part8
    8859part9
    GB2312
    big5
    ebcdic
    eucJP
    eucKR
    jis
    shiftJIS
    ucs2
    ucs4
    usAscii
    utf16
    utf7
    utf8
  }
  Constraint Enum "GN_NamedPlaceTypeValue" {
    identifier = "Geographical Names::NamedPlaceTypeValue"
    administrativeUnit
    building
    hydrography
    landcover
    landform
    other
    populatedPlace
    protectedSite
    transportNetwork
  }
  Constraint Enum "ACT_CORE_EconomicActivityValue" {
    identifier = "Activity Complex::EconomicActivityValue"
  }
  Constraint Enum "ACT_CORE_InputOutputValue" {
    identifier = "Activity Complex::InputOutputValue"
  }
  Constraint Enum "AD_StatusValue" {
    identifier = "Addresses::StatusValue"
    alternative
    current
    proposed
    reserved
    retired
  }
  Constraint Enum "AD_LocatorLevelValue" {
    identifier = "Addresses::LocatorLevelValue"
    accessLevel
    postalDeliveryPoint
    siteLevel
    unitLevel
  }
  Constraint Enum "AD_GeometrySpecificationValue" {
    identifier = "Addresses::GeometrySpecificationValue"
    addressArea
    adminUnit1stOrder
    adminUnit2ndOrder
    adminUnit3rdOrder
    adminUnit4thOrder
    adminUnit5thOrder
    adminUnit6thOrder
    building
    entrance
    parcel
    postalDelivery
    postalDescriptor
    segment
    thoroughfareAccess
    utilityService
  }
  Constraint Enum "AD_GeometryMethodValue" {
    identifier = "Addresses::GeometryMethodValue"
    byAdministrator
    byOtherParty
    fromFeature
  }
  Constraint Enum "AD_LocatorDesignatorTypeValue" {
    identifier = "Addresses::LocatorDesignatorTypeValue"
    addressIdentifierGeneral
    addressNumber
    addressNumber2ndExtension
    addressNumberExtension
    buildingIdentifier
    buildingIdentifierPrefix
    cornerAddress1stIdentifier
    cornerAddress2ndIdentifier
    entranceDoorIdentifier
    floorIdentifier
    kilometrePoint
    postalDeliveryIdentifier
    staircaseIdentifier
    unitIdentifier
  }
  Constraint Enum "AD_LocatorNameTypeValue" {
    identifier = "Addresses::LocatorNameTypeValue"
    buildingName
    descriptiveLocator
    roomName
    siteName
  }
  Attributes "BU_BASE_CurrentUse" {
    description = "This data type enables to detail the current use(s)."
    identifier = "BuildingsBase::CurrentUse"
    tableName = "BU_BASE_CurrentUse"
    currentUse TEXT NOT NULL CHECK(BU_BASE_CurrentUseValue)
    id INTEGER NOT NULL PRIMARY KEY
    percentage INTEGER
  }
  Attributes "BU_BASE_Elevation" {
    description = "This data types includes the elevation value itself  and information on how this elevation was measured."
    identifier = "BuildingsBase::Elevation"
    tableName = "BU_BASE_Elevation"
    elevationReference TEXT NOT NULL CHECK(BU_BASE_ElevationReferenceValue)
    elevationValue_coordinate <<missing>> NOT NULL
    elevationValue_dimension INTEGER NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "BU_BASE_ExternalReference" {
    description = "Reference to an external information system containing any piece of information related to the spatial object."
    identifier = "BuildingsBase::ExternalReference"
    tableName = "BU_BASE_ExternalReference"
    id INTEGER NOT NULL PRIMARY KEY
    informationSystem TEXT NOT NULL
    reference TEXT NOT NULL
  }
  Attributes "BU_BASE_HeightAboveGround" {
    description = "Vertical distance (measured or estimated) between a low reference and a high reference."
    identifier = "BuildingsBase::HeightAboveGround"
    tableName = "BU_BASE_HeightAboveGround"
    heightReference TEXT CHECK(BU_BASE_ElevationReferenceValue)
    id INTEGER NOT NULL PRIMARY KEY
    lowReference TEXT CHECK(BU_BASE_ElevationReferenceValue)
    status TEXT CHECK(BU_BASE_HeightStatusValue)
    value TEXT NOT NULL
    value_uom TEXT NOT NULL CHECK(GML_UomIdentifier)
  }
  Constraint Enum "BU_BASE_HorizontalGeometryReferenceValue" {
    obligation = "implementingRule"
    identifier = "BuildingsBase::HorizontalGeometryReferenceValue"
  }
  Constraint Enum "BU_BASE_ElevationReferenceValue" {
    obligation = "implementingRule"
    identifier = "BuildingsBase::ElevationReferenceValue"
  }
  Constraint Enum "BU_BASE_BuildingNatureValue" {
    obligation = "implementingRule"
    identifier = "BuildingsBase::BuildingNatureValue"
  }
  Constraint Enum "BU_BASE_ConditionOfConstructionValue" {
    obligation = "implementingRule"
    identifier = "BuildingsBase::ConditionOfConstructionValue"
  }
  Constraint Enum "BU_BASE_CurrentUseValue" {
    extensiblity = "narrower"
    obligation = "implementingRule"
    identifier = "BuildingsBase::CurrentUseValue"
  }
  Constraint Enum "BU_BASE_HeightStatusValue" {
    obligation = "implementingRule"
    identifier = "BuildingsBase::HeightStatusValue"
  }
  Constraint Enum "CP_CadastralZoningLevelValue" {
    identifier = "CadastralParcels::CadastralZoningLevelValue"
    1stOrder
    2ndOrder
    3rdOrder
  }
}
