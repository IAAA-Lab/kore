Container <<applicationSchema>>  "MineralResources" {
  Constraint Enum "MR_CORE_ImportanceValue" {
    identifier = "MineralResources::ImportanceValue"
  }
  Constraint Enum "MR_CORE_CommodityCodeValue" {
    identifier = "MineralResources::CommodityCodeValue"
  }
  Attributes "MR_CORE_MiningActivity" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "The process of extracting metallic, non-metallic mineral, or industrial rock deposits from the Earth.
  
    The term may also include preliminary treatment eg. cleaning or sizing."
    identifier = "MineralResources::MiningActivity"
    tableName = "MR_CORE_MiningActivity"
    activityType TEXT NOT NULL CHECK(MR_CORE_MiningActivityTypeValue)
    associatedMine INTEGER
    id INTEGER NOT NULL PRIMARY KEY
    oreProcessed Quantity
    processingType TEXT NOT NULL CHECK(MR_CORE_ProcessingActivityTypeValue)
    ref inspireId: BASE_Identifier
  }
  Class <<type>>  "MineralDepositModel" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xmlSchemaType = "#NOTES#Description: If the type has a canonical XML Schema encoding the XML Schema typename corresponding to the data type shall be given as the value (applies to ISO 19136:2007 encoding rule)
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    ref mineralDepositGroup: MR_CORE_MineralDepositGroupValue[1..*]
    ref mineralDepositType: MR_CORE_MineralDepositTypeValue[0..*]
  }
  Constraint Enum "MR_CORE_ResourceCategoryValue" {
    identifier = "MineralResources::ResourceCategoryValue"
  }
  Constraint Enum "MR_CORE_ClassificationMethodUsedValue" {
    identifier = "MineralResources::ClassificationMethodUsedValue"
  }
  Constraint Enum "MR_CORE_ProcessingActivityTypeValue" {
    identifier = "MineralResources::ProcessingActivityTypeValue"
  }
  Constraint Enum "MR_CORE_MineralOccurrenceTypeValue" {
    identifier = "MineralResources::MineralOccurrenceTypeValue"
  }
  Attributes "MR_CORE_CommodityMeasure" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "A measure of the amount of the commodity based on a Reserve, Resource or Endowment calculation.
  
    Where OreMeasure is Resource or Reserve CommodityMeasure is mandatory"
    identifier = "MineralResources::CommodityMeasure"
    tableName = "MR_CORE_CommodityMeasure"
    commodityAmount QuantityRange
    cutOffGrade QuantityRange
    grade QuantityRange
    id INTEGER NOT NULL PRIMARY KEY
  }
  Constraint Enum "MR_CORE_ExplorationResultValue" {
    identifier = "MineralResources::ExplorationResultValue"
  }
  Constraint Enum "MR_CORE_MineralDepositGroupValue" {
    identifier = "MineralResources::MineralDepositGroupValue"
  }
  Attributes "MR_CORE_Endowment" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "The quantity of a mineral (or a group of minerals for industrial rocks) in accumulations (deposits) meeting specified physical characteristics such as quality, size and depth.
  
    Usually includes Resources, as unlike the latter, it does not have to have prospects for "eventual economic extraction". It often includes the total amount of a commodity originally introduced to a particular location during the deposit forming processes - and thus can include resources, reserves, past production and mining and metallurgical losses."
    identifier = "MineralResources::Endowment"
    tableName = "MR_CORE_Endowment"
    classificationMethodUsed: TEXT
    id INTEGER NOT NULL PRIMARY KEY
    includesReserves BOOLEAN
    includesResources BOOLEAN
    ore: QuantityRange
    proposedExtractionMethod: Category [0..1]
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref sourceReference: DocumentCitation[1..*]
  }
  Class "EarthResource" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    beginLifespanVersion: DATETIME [0..1]
    endLifespanversion: DATETIME [0..1]
    name: TEXT [0..1]
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref expression: Category[0..*]
    ref form: Category[0..*]
    ref inspireId: BASE_Identifier
    ref linearOrientation: CGU_CGI_LinearOrientation[0..*]
    ref planarOrientation: CGU_CGI_PlanarOrientation[0..*]
    ref shape: Category[0..*]
    ref sourceReference: DocumentCitation[0..*]
    ref MappedFeature inv specification
  }
  Attributes "MR_CORE_ExplorationActivity" {
    description = "A period of exploration activity."
    identifier = "MineralResources::ExplorationActivity"
    tableName = "MR_CORE_ExplorationActivity"
    activityType TEXT NOT NULL CHECK(MR_CORE_ExplorationActivityTypeValue)
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "MR_CORE_Reserve" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "The economically mineable part of a Measured and/or Indicated Mineral Resource.
  
    It includes diluting materials and allowances for losses, which may occur when the material is mined. &lsquo;Marketable Coal Reserves&rsquo; maybe reported in conjunction with, but not instead of, reports of Ore (Coal) Reserves. &lsquo;Saleable product&rsquo; (e.g. for industrial minerals) can be reported in conjunction with ore reserve.
  
    Synonyms: Ore Reserve; Coal Reserve (s); Diamond (or gemstone) Ore Reserve; Mineral Reserves (not preferred, should be stated that used to mean the same as JORC&rsquo;s Ore Reserve); Mineable production estimates"
    identifier = "MineralResources::Reserve"
    tableName = "MR_CORE_Reserve"
    category TEXT NOT NULL CHECK(MR_CORE_ReserveCategoryValue)
    classificationMethodUsed: TEXT
    id INTEGER NOT NULL PRIMARY KEY
    ore: QuantityRange
    proposedExtractionMethod: Category [0..1]
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref sourceReference: DocumentCitation[1..*]
  }
  Constraint Enum "MR_CORE_MiningActivityTypeValue" {
    identifier = "MineralResources::MiningActivityTypeValue"
  }
  Attributes "MR_CORE_Resource" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "An accumulation of material of intrinsic economic interest in or on the Earth&rsquo;s crust in such form, quality and quantity that there are reasonable prospects for economic extraction.
  
    Synonyms: Mineral Resource; Coal Resource (s); Diamond (Gemstone) Resource; Potentially Mineable Mineralisation."
    identifier = "MineralResources::Resource"
    tableName = "MR_CORE_Resource"
    category TEXT NOT NULL CHECK(MR_CORE_ResourceCategoryValue)
    classificationMethodUsed: TEXT
    id INTEGER NOT NULL PRIMARY KEY
    includesReserves BOOLEAN
    ore: QuantityRange
    proposedExtractionMethod: Category [0..1]
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref sourceReference: DocumentCitation[1..*]
  }
  Attributes "MR_CORE_MineName" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "A  data type indicating the Mine Name and whether it is the preferred name."
    identifier = "MineralResources::MineName"
    tableName = "MR_CORE_MineName"
    id INTEGER NOT NULL PRIMARY KEY
    isPreferred BOOLEAN NOT NULL
    mineName TEXT NOT NULL
  }
  Constraint Enum "MR_CORE_ExplorationActivityTypeValue" {
    identifier = "MineralResources::ExplorationActivityTypeValue"
  }
  Attributes "MR_CORE_EarthResourceDimension" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "The size and volume of the earth resource."
    identifier = "MineralResources::EarthResourceDimension"
    tableName = "MR_CORE_EarthResourceDimension"
    id INTEGER NOT NULL PRIMARY KEY
    ref area: QuantityRange[0..*]
    ref depth: QuantityRange[0..*]
    ref length: QuantityRange[0..*]
    ref width: QuantityRange[0..*]
  }
  Class "MiningFeature" {
    ref inspireId: BASE_Identifier
  }
  Attributes "MR_CORE_Commodity" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "The material of economic interest in the EarthResource"
    identifier = "MineralResources::Commodity"
    tableName = "MR_CORE_Commodity"
    commodity TEXT NOT NULL CHECK(MR_CORE_CommodityCodeValue)
    commodityImportance TEXT CHECK(MR_CORE_ImportanceValue)
    commodityRank INTEGER
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "MR_CORE_Mine" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "An excavation carried out for the extraction of mineral deposits.
  
    &lsquo;True&rsquo; mines are underground workings and open-pit workings (also called open-sky mines) generally for the extraction of metallic commodities. The Mine feature also includes open workings generally for the extraction of industrial minerals, commonly referred to as quarries."
    identifier = "MineralResources::Mine"
    tableName = "MR_CORE_Mine"
    beginLifespanVersion DATETIME
    endDate_position_anyOther_indeterminatePosition TEXT CHECK(TRS_TM_IndeterminateValue)
    endDate_position_date8601 DATE
    endDate_position_dateTime8601 DATETIME
    endDate_position_time8601 TEXT
    endDate_position_time8601_uom TEXT CHECK(GML_UomIdentifier)
    endLifespanVersion DATETIME
    id INTEGER NOT NULL PRIMARY KEY
    startDate_position_anyOther_indeterminatePosition TEXT CHECK(TRS_TM_IndeterminateValue)
    startDate_position_date8601 DATE
    startDate_position_dateTime8601 DATETIME
    startDate_position_time8601 TEXT
    startDate_position_time8601_uom TEXT CHECK(GML_UomIdentifier)
    status TEXT NOT NULL CHECK(MR_CORE_MineStatusValue)
    ref inspireId: BASE_Identifier
    ref sourceReference: DocumentCitation[0..*]
  }
  Constraint Enum "MR_CORE_MineralDepositTypeValue" {
    identifier = "MineralResources::MineralDepositTypeValue"
  }
  Attributes "MR_CORE_MineralOccurrence" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    description = "<font color="#400040">A mineral accumulation in the lithosphere. </font>"
    identifier = "MineralResources::MineralOccurrence"
    tableName = "MR_CORE_MineralOccurrence"
    beginLifespanVersion: DATETIME [0..1]
    endLifespanversion: DATETIME [0..1]
    id INTEGER NOT NULL PRIMARY KEY
    name: TEXT [0..1]
    type TEXT NOT NULL CHECK(MR_CORE_MineralOccurrenceTypeValue)
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref expression: Category[0..*]
    ref form: Category[0..*]
    ref inspireId: BASE_Identifier
    ref linearOrientation: CGU_CGI_LinearOrientation[0..*]
    ref planarOrientation: CGU_CGI_PlanarOrientation[0..*]
    ref shape: Category[0..*]
    ref sourceReference: DocumentCitation[0..*]
    ref MappedFeature inv specification
  }
  Feature "MR_CORE_MiningFeatureOccurrence" {
    description = "A spatial representation of a MiningFeature.
  
    A MiningFeatureOccurrence provides a link between a notional feature (description package) and one spatial representation of it, or part of it. The MiningFeatureOccurrence carries a geometry and the association with a Mining Feature provides specification of all the other descriptors."
    identifier = "MineralResources::MiningFeatureOccurrence"
    tableName = "MR_CORE_MiningFeatureOccurrence"
    id INTEGER NOT NULL PRIMARY KEY
    shape GEOMETRY NOT NULL
  }
  Constraint Enum "MR_CORE_MineStatusValue" {
    identifier = "MineralResources::MineStatusValue"
  }
  Class "OreMeasure" {
    hasXmlLang = "false#NOTES#Values: true | false
    Default: false
    Description: axml attribute xml:lang shall be generated for the type representing the class
    "
    xsdCanonicalElement = "#NOTES#Description: no element shall be generated for the class, but the given type or element referenced
    "
    xsdCanonicalPropertyGroup = "#NOTES#Description: group to be referenced if the class is used as a type of a property
    "
    xsdCanonicalPropertyType = "#NOTES#Description: type to be referenced if the class is used as a type of a property
    "
    xsdCanonicalType = "#NOTES#Description: no type shall be generated for the class, but the given type or element referenced
    "
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    xsdName = "#NOTES#Description: value to be used for the schema conversion instead of the UML name
    "
    classificationMethodUsed: TEXT
    ore: QuantityRange
    proposedExtractionMethod: Category [0..1]
    ref dimension: MR_CORE_EarthResourceDimension[0..1]
    ref sourceReference: DocumentCitation[1..*]
  }
  Constraint Enum "MR_CORE_EndusePotentialValue" {
    identifier = "MineralResources::EndusePotentialValue"
  }
  Constraint Enum "MR_CORE_ReserveCategoryValue" {
    identifier = "MineralResources::ReserveCategoryValue"
  }
  Attributes "MR_CORE_MineralDepositGroupValue" {
    description = "Values indicating the grouping of mineral deposits on the basis of their generic characteristics.
  
    EXAMPLE: host rock, host structure, commodity, association with similar mineral processes e.g. porphyry."
    identifier = "MineralResources::MineralDepositGroupValue"
    tableName = "MR_CORE_MineralDepositGroupValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(MR_CORE_MineralDepositGroupValue)
  }
  Attributes "MR_CORE_MineralDepositTypeValue" {
    description = "Values indicating the style of mineral occurrence or deposit.
  
    Generally a local or regional term. Should be referenced for definitions and descriptions. Single deposit terms may form member of a Mineral Deposit Group in local and regional schemas."
    identifier = "MineralResources::MineralDepositTypeValue"
    tableName = "MR_CORE_MineralDepositTypeValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(MR_CORE_MineralDepositTypeValue)
  }
  Attributes "MR_CORE_ExplorationResultValue" {
    description = "Values indicating the result of the exploration activity."
    identifier = "MineralResources::ExplorationResultValue"
    tableName = "MR_CORE_ExplorationResultValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(MR_CORE_ExplorationResultValue)
  }
  Attributes "MR_CORE_EndusePotentialValue" {
    description = "Values indicating the end-use potential of the mineral.
  
    <font color="#211d1e">EXAMPLE: </font>for energy, fertilizer, building raw material etc.
  
    <font color="#211d1e">
  
    </font>"
    identifier = "MineralResources::EndusePotentialValue"
    tableName = "MR_CORE_EndusePotentialValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(MR_CORE_EndusePotentialValue)
  }
  Relation "MR_CORE_MiningActivity_associatedMine" {
    profile = "attributes"
    relatedReference = "MR_CORE_MiningActivity#associatedMine"
    tableName = "MR_CORE_MiningActivity_associatedMine"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_MiningActivity(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_Mine(id)
  }
  Relation "MR_CORE_CommodityMeasure_commodityOfInterest" {
    profile = "attributes"
    tableName = "MR_CORE_CommodityMeasure_commodityOfInterest"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_CommodityMeasure(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_Commodity(id)
  }
  Relation "MR_CORE_ExplorationActivity_explorationResult" {
    profile = "attributes"
    tableName = "MR_CORE_ExplorationActivity_explorationResult"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_ExplorationActivity(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_ExplorationResultValue(id)
  }
  Relation "MR_CORE_Mine_relatedActivity" {
    profile = "attributes"
    tableName = "MR_CORE_Mine_relatedActivity"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_Mine(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_MiningActivity(id)
  }
  Relation "MR_CORE_Mine_relatedMine" {
    profile = "attributes"
    tableName = "MR_CORE_Mine_relatedMine"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_Mine(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_Mine(id)
  }
  Relation "MR_CORE_Mine_mineName" {
    profile = "attributes"
    tableName = "MR_CORE_Mine_mineName"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_Mine(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_MineName(id)
  }
  Relation "MR_CORE_MineralOccurrence_endusePotential" {
    profile = "attributes"
    tableName = "MR_CORE_MineralOccurrence_endusePotential"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES MR_CORE_MineralOccurrence(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES MR_CORE_EndusePotentialValue(id)
  }
  Metadata "Unknown" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attribute"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Unpopulated" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attributeType"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Withheld" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attribute"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Metadata "Withheld" {
    metadata = ""
    mimeType = "text/xml"
    scope = "attributeType"
    standardUri = "http://www.isotc211.org/2005/gmd"
  }
  Relation "GE_GeologicEvent_eventProcess" {
    profile = "attributes"
    tableName = "GE_GeologicEvent_eventProcess"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GE_GeologicEvent(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GE_EventProcessValue(id)
  }
  Relation "GMD_CI_Citation_date" {
    profile = "attributes"
    tableName = "GMD_CI_Citation_date"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GMD_CI_Citation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_CI_Date(id)
  }
  Relation "GMD_CI_Citation_citedResponsibleParty" {
    profile = "attributes"
    tableName = "GMD_CI_Citation_citedResponsibleParty"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GMD_CI_Citation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_CI_ResponsibleParty(id)
  }
  Relation "GMD_CI_Citation_presentationForm" {
    profile = "attributes"
    tableName = "GMD_CI_Citation_presentationForm"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GMD_CI_Citation(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_CI_PresentationFormCode(id)
  }
  Relation "GMD_CI_ResponsibleParty_contactInfo_phone" {
    profile = "attributes"
    relatedReference = "GMD_CI_ResponsibleParty#contactInfo_phone"
    tableName = "GMD_CI_ResponsibleParty_contactInfo_phone"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GMD_CI_ResponsibleParty(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_CI_Telephone(id)
  }
  Relation "GMD_CI_ResponsibleParty_contactInfo_address" {
    profile = "attributes"
    relatedReference = "GMD_CI_ResponsibleParty#contactInfo_address"
    tableName = "GMD_CI_ResponsibleParty_contactInfo_address"
    base_id INTEGER NOT NULL FOREIGN KEY (base_id) REFERENCES GMD_CI_ResponsibleParty(id)
    related_id INTEGER NOT NULL FOREIGN KEY (related_id) REFERENCES GMD_CI_Address(id)
  }
  Constraint Enum "TRS_TM_IndeterminateValue" {
    identifier = "Temporal Reference System::TM_IndeterminateValue"
    after
    before
    name
    now
    unknow
  }
  Constraint Enum "GML_UomIdentifier" {}
  Attributes "BASE_Identifier" {
    description = "External unique object identifier published by the responsible body, which may be used by external applications to reference the spatial object.
  
    NOTE1 External object identifiers are distinct from thematic object identifiers.
  
    NOTE 2 The voidable version identifier attribute is not part of the unique identifier of a spatial object and may be used to distinguish two versions of the same spatial object.
  
    NOTE 3 The unique identifier will not change during the life-time of a spatial object."
    identifier = "Base Types::Identifier"
    tableName = "BASE_Identifier"
    id INTEGER NOT NULL PRIMARY KEY
    localId TEXT NOT NULL
    namespace TEXT NOT NULL
    versionId TEXT
  }
  Attributes "CGU_CGI_LinearOrientation" {
    description = "Description of the measured orientation of a line.  At least one of plunge or trend should not be nil."
    identifier = "CGI_Value::CGI_LinearOrientation"
    tableName = "CGU_CGI_LinearOrientation"
    determinationMethod: TEXT
    id INTEGER NOT NULL PRIMARY KEY
    plunge_estimatedValue Quantity NOT NULL
    trend_estimatedValue Quantity NOT NULL
    directed TEXT NOT NULL CHECK(CGU_LinearDirectedCode)
    ref <<estimatedProperty>> descriptiveOrientation: CGU_CGI_Term
  }
  Attributes "CGU_CGI_PlanarOrientation" {
    description = "Description of the geometry of a plane."
    identifier = "CGI_Value::CGI_PlanarOrientation"
    tableName = "CGU_CGI_PlanarOrientation"
    azimuth_estimatedValue Quantity NOT NULL
    convention TEXT NOT NULL CHECK(CGU_ConventionCode)
    determinationMethod: TEXT
    dip_estimatedValue Quantity NOT NULL
    id INTEGER NOT NULL PRIMARY KEY
    polarity TEXT NOT NULL CHECK(CGU_PlanarPolarityCode)
    ref <<estimatedProperty>> descriptiveOrientation: CGU_CGI_Term
  }
  Attributes "GE_GeologicEvent" {
    description = "An identifiable event during which one or more geological processes act to modify geological entities.
  
    A GeologicEvent should have a specified geologic age and process, and may have a specified environment. An example might be a cratonic uplift event during which erosion, sedimentation, and volcanism all take place. A GeologicEvent age can represent an instant in time or an interval of time."
    identifier = "Geology::GeologicEvent"
    tableName = "GE_GeologicEvent"
    eventEnvironment TEXT CHECK(GE_EventEnvironmentValue)
    id INTEGER NOT NULL PRIMARY KEY
    name TEXT
    olderNamedAge TEXT CHECK(GE_GeochronologicEraValue)
    youngerNamedAge TEXT CHECK(GE_GeochronologicEraValue)
  }
  Attributes "GE_ThematicClass" {
    description = "A generic thematic classifier to enable the reclassification of Geologic Features with user defined classes appropriate to thematic maps.
  
    This datatype allows Geologic Features to be classified against thematic classes. This provides a generic means of delivering geological thematic map data."
    identifier = "Geology::ThematicClass"
    tableName = "GE_ThematicClass"
    id INTEGER NOT NULL PRIMARY KEY
    themeClass TEXT NOT NULL CHECK(GE_ThematicClassValue)
    themeClassification TEXT NOT NULL CHECK(GE_ThematicClassificationValue)
  }
  Attributes "GE_EventProcessValue" {
    description = "Terms specifying the process or processes that occurred during an event.
  
    EXAMPLE: deposition, extrusion, intrusion, cooling."
    identifier = "Geology::EventProcessValue"
    tableName = "GE_EventProcessValue"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(GE_EventProcessValue)
  }
  Attributes "GMD_CI_Citation" {
    description = "Standardized resource reference"
    identifier = "Citation and responsible party information::CI_Citation"
    tableName = "GMD_CI_Citation"
    ISBN TEXT
    ISSN TEXT
    collectiveTitle TEXT
    edition TEXT
    editionDate DATE
    id INTEGER NOT NULL PRIMARY KEY
    otherCitationDetails TEXT
    series_issueIdentification TEXT
    series_name TEXT
    series_page TEXT
    title TEXT NOT NULL
    ref alternateTitle: TEXT[0..*]
    ref identifier: MD_Identifier[0..*]
  }
  Attributes "GMD_CI_Date" {
    identifier = "Citation and responsible party information::CI_Date"
    tableName = "GMD_CI_Date"
    date DATE NOT NULL
    dateType TEXT NOT NULL CHECK(GMD_CI_DateTypeCode)
    id INTEGER NOT NULL PRIMARY KEY
  }
  Attributes "GMD_CI_ResponsibleParty" {
    description = "Identification of, and means of communication with, person(s) and organisations associated with the dataset"
    identifier = "Citation and responsible party information::CI_ResponsibleParty"
    tableName = "GMD_CI_ResponsibleParty"
    contactInfo_address INTEGER
    contactInfo_contactInstructions TEXT
    contactInfo_hoursOfService TEXT
    contactInfo_onlineResource_applicationProfile TEXT
    contactInfo_onlineResource_description TEXT
    contactInfo_onlineResource_function TEXT CHECK(GMD_CI_OnLineFunctionCode)
    contactInfo_onlineResource_name TEXT
    contactInfo_onlineResource_protocol TEXT
    contactInfo_phone INTEGER
    id INTEGER NOT NULL PRIMARY KEY
    individualName TEXT
    organisationName TEXT
    positionName TEXT
    role TEXT NOT NULL CHECK(GMD_CI_RoleCode)
  }
  Attributes "GMD_CI_PresentationFormCode" {
    description = "Mode in which the data is represented"
    identifier = "Citation and responsible party information::CI_PresentationFormCode"
    tableName = "GMD_CI_PresentationFormCode"
    id INTEGER NOT NULL PRIMARY KEY
    value TEXT NOT NULL CHECK(GMD_CI_PresentationFormCode)
  }
  Attributes "GMD_CI_Telephone" {
    description = "Telephone numbers for contacting the responsible individual or organisation"
    identifier = "Citation and responsible party information::CI_Telephone"
    tableName = "GMD_CI_Telephone"
    id INTEGER NOT NULL PRIMARY KEY
    ref facsimile: TEXT[0..*]
    ref voice: TEXT[0..*]
  }
  Attributes "GMD_CI_Address" {
    description = "Location of the responsible individual or organisation"
    identifier = "Citation and responsible party information::CI_Address"
    tableName = "GMD_CI_Address"
    administrativeArea TEXT
    city TEXT
    country TEXT
    id INTEGER NOT NULL PRIMARY KEY
    postalCode TEXT
    ref deliveryPoint: TEXT[0..*]
    ref electronicMailAddress: TEXT[0..*]
  }
  Attributes "SWE_RealPair" {
    asXMLList = "true"
    xsdDerivation = "true#NOTES#Values: true | false
    Default: true
    Description: class implemented as new type + element, or by applying constraints only
    "
    identifier = "Basic Types::RealPair"
    tableName = "SWE_RealPair"
    id INTEGER NOT NULL PRIMARY KEY
    ref <<property>> item: DOUBLE[2..2]
  }
  Attributes "CGU_CGI_Term" {
    identifier = "CGI_Value::CGI_Term"
    tableName = "CGU_CGI_Term"
    id INTEGER NOT NULL PRIMARY KEY
    qualifier TEXT NOT NULL CHECK(CGU_ValueQualifierCode)
    value TEXT NOT NULL CHECK(CGU_CodeListValue)
  }
  Constraint Enum "GML_MeasureType" {
    identifier = "Units of Measure::MeasureType"
    angle
    area
    length
    scale
    time
    velocity
    volume
    weight
  }
  Constraint Enum "GMD_CI_DateTypeCode" {
    identifier = "Citation and responsible party information::CI_DateTypeCode"
    creation
    publication
    revision
  }
  Constraint Enum "CGU_LinearDirectedCode" {
    identifier = "CGI_Value::LinearDirectedCode"
    directed
    directed down
    directed up
  }
  Constraint Enum "CGU_DeterminationMethodTerm" {
    identifier = "CGI_Value::DeterminationMethodTerm"
  }
  Constraint Enum "CGU_ConventionCode" {
    identifier = "CGI_Value::ConventionCode"
    dip dip direction
    strike dip right hand rule
  }
  Constraint Enum "CGU_PlanarPolarityCode" {
    identifier = "CGI_Value::PlanarPolarityCode"
    overturned
    upright
    vertical
  }
  Constraint Enum "GE_EventEnvironmentValue" {
    identifier = "Geology::EventEnvironmentValue"
  }
  Constraint Enum "GE_GeochronologicEraValue" {
    identifier = "Geology::GeochronologicEraValue"
  }
  Constraint Enum "GE_ThematicClassificationValue" {
    identifier = "Geology::ThematicClassificationValue"
  }
  Constraint Enum "GE_ThematicClassValue" {
    identifier = "Geology::ThematicClassValue"
  }
  Constraint Enum "GE_EventProcessValue" {
    identifier = "Geology::EventProcessValue"
  }
  Constraint Enum "GMD_CI_OnLineFunctionCode" {
    identifier = "Citation and responsible party information::CI_OnLineFunctionCode"
    download
    information
    offlineAccess
    order
    search
  }
  Constraint Enum "GMD_CI_RoleCode" {
    identifier = "Citation and responsible party information::CI_RoleCode"
    author
    custodian
    distributor
    originator
    owner
    pointOfContact
    principalInvestigator
    processor
    publisher
    resourceProvider
    user
  }
  Constraint Enum "GMD_CI_PresentationFormCode" {
    identifier = "Citation and responsible party information::CI_PresentationFormCode"
    documentDigital
    documentHardcopy
    imageDigital
    imageHardcopy
    mapDigital
    mapHardcopy
    modelDigital
    modelHardcopy
    profileDigital
    profileHardcopy
    tableDigital
    tableHardcopy
    videoDigital
    videoHardcopy
  }
  Attributes "SWE_NilValue" {
    xsdDerivation = "false"
    identifier = "Basic Types::NilValue"
    tableName = "SWE_NilValue"
    id INTEGER NOT NULL PRIMARY KEY
    reason ScopedName NOT NULL
    value TEXT NOT NULL
  }
  Constraint Enum "CGU_ValueQualifierCode" {
    identifier = "CGI_Value::ValueQualifierCode"
    always
    approximate
    common
    equalTo
    greaterThan
    lessThan
    never
    rare
    sometimes
  }
  Constraint Enum "CGU_CodeListValue" {
    identifier = "CGI_Value::CodeListValue"
  }
  Constraint Enum "GMD_DQ_EvaluationMethodTypeCode" {
    identifier = "Data quality information::DQ_EvaluationMethodTypeCode"
    directExternal
    directInternal
    indirect
  }
  Constraint Enum "SC_CV_CommonPointRule" {
    identifier = "Segmented Curve::CV_CommonPointRule"
    all
    average
    end
    high
    low
    start
  }
}
